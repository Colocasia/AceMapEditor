# AceMapEditor 代码规范

## 命名约定

### C# 命名规则

#### 类和结构体
```csharp
// PascalCase
public class TerrainEditor { }
public struct TerrainVertex { }
```

#### 接口
```csharp
// I前缀 + PascalCase
public interface ITerrainAdapter { }
public interface ITextureBlendAdapter { }
```

#### 方法
```csharp
// PascalCase
public void RaiseTerrain() { }
private void CalculateNormals() { }
```

#### 属性
```csharp
// PascalCase
public float BrushSize { get; set; }
public int LayerCount { get; private set; }
```

#### 字段

**公共字段**（尽量避免使用）
```csharp
// PascalCase
public float MaxHeight;
```

**私有字段**
```csharp
// camelCase
private float brushStrength;
private SplatMapManager splatMapManager;
```

**常量**
```csharp
// UPPER_SNAKE_CASE
private const int MAX_TEXTURE_LAYERS = 32;
private const float DEFAULT_BRUSH_SIZE = 10.0f;
```

#### 参数和局部变量
```csharp
// camelCase
public void SetWeight(int x, int y, float weight)
{
    int pixelIndex = x + y * resolution;
    float normalizedWeight = Mathf.Clamp01(weight);
}
```

#### 命名空间
```csharp
// PascalCase，按目录结构组织
namespace AceMapEditor.Core.Terrain { }
namespace AceMapEditor.Editor.Tools { }
namespace AceMapEditor.Unity.Adapters { }
```

---

## 文件组织

### 文件命名
- 一个文件一个类（推荐）
- 文件名与类名一致
- 使用 `.cs` 扩展名

```
TerrainEditor.cs
ITerrainAdapter.cs
UnityTerrainAdapter.cs
```

### 文件头注释
```csharp
// AceMapEditor/Core/Editor/TerrainEditor.cs
// 地形编辑器核心逻辑
// Author: [Your Name]
// Created: 2025-01-18

using System;
using System.Collections.Generic;
```

### Using 声明顺序
1. System命名空间
2. Unity命名空间（仅Unity特定代码）
3. 第三方库
4. 项目命名空间

```csharp
using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEditor;
using Newtonsoft.Json;
using AceMapEditor.Core.Data;
using AceMapEditor.Core.Interfaces;
```

---

## 注释规范

### XML 文档注释
对所有公共API使用XML注释

```csharp
/// <summary>
/// 地形编辑器，负责地形高度和纹理编辑
/// </summary>
public class TerrainEditor
{
    /// <summary>
    /// 升高地形
    /// </summary>
    /// <param name="position">中心位置（网格坐标）</param>
    /// <param name="radius">笔刷半径（单位：格）</param>
    /// <param name="strength">笔刷强度（0-1）</param>
    public void RaiseTerrain(Vector2Int position, float radius, float strength)
    {
        // 实现...
    }
}
```

### 行内注释
```csharp
// 计算距离衰减
float distance = Mathf.Sqrt(x * x + y * y);
float falloff = 1f - (distance / radius);

// TODO: 优化性能，使用Job System
// FIXME: 边界检查有bug
// NOTE: 这里使用平方根衰减效果更自然
```

### 区域标记（可选）
```csharp
#region Public Methods

public void RaiseTerrain() { }
public void LowerTerrain() { }

#endregion

#region Private Methods

private void CalculateNormals() { }

#endregion
```

---

## 代码格式

### 缩进和空格
- 使用 **4个空格** 缩进（不使用Tab）
- 花括号独占一行（Allman风格）

```csharp
public class TerrainEditor
{
    public void RaiseTerrain()
    {
        if (condition)
        {
            DoSomething();
        }
    }
}
```

### 行长度
- 每行代码不超过 **120个字符**
- 超过时合理换行

```csharp
// 好
var result = CalculateComplexValue(
    parameter1,
    parameter2,
    parameter3
);

// 避免
var result = CalculateComplexValue(parameter1, parameter2, parameter3, parameter4, parameter5);
```

### 空行使用
```csharp
public class Example
{
    // 字段声明后空一行
    private int value;

    // 方法之间空一行
    public void Method1()
    {
        // 逻辑块之间空行
        PrepareData();

        ProcessData();

        CleanUp();
    }

    public void Method2()
    {
        // ...
    }
}
```

---

## 可移植性规则

### Core 层代码规则

**禁止**：
```csharp
// ❌ 不要在Core层直接使用Unity类型
using UnityEngine;

public class TerrainData
{
    public Vector3 position;  // ❌ 错误
}
```

**推荐**：
```csharp
// ✅ 使用纯C#类型或自定义结构（优先使用struct）
using System.Numerics;

public class TerrainData
{
    public Vector3 position;  // ✅ 使用System.Numerics.Vector3
}

// ✅ 更好：自定义readonly struct，性能更优
public readonly struct Vector3f
{
    public readonly float x, y, z;

    public Vector3f(float x, float y, float z)
    {
        this.x = x;
        this.y = y;
        this.z = z;
    }
}
```

### 接口使用
```csharp
// Core层定义接口
namespace AceMapEditor.Core.Interfaces
{
    public interface ITerrainAdapter
    {
        void SetHeight(int x, int z, float height);
    }
}

// Unity层实现接口
namespace AceMapEditor.Unity.Adapters
{
    public class UnityTerrainAdapter : ITerrainAdapter
    {
        public void SetHeight(int x, int z, float height)
        {
            // Unity特定实现
        }
    }
}
```

---

## 最佳实践

### 使用属性而非公共字段
```csharp
// ❌ 避免
public float brushSize;

// ✅ 推荐
public float BrushSize { get; set; }

// ✅ 更好（带验证）
private float brushSize;
public float BrushSize
{
    get => brushSize;
    set => brushSize = Mathf.Max(0, value);
}
```

### 使用readonly
```csharp
public class TerrainChunk
{
    // 只在构造函数中赋值的字段使用readonly
    private readonly int resolution;
    private readonly Mesh mesh;

    public TerrainChunk(int resolution)
    {
        this.resolution = resolution;
        this.mesh = new Mesh();
    }
}
```

### 空值检查
```csharp
// 使用空值合并运算符
var manager = splatMapManager ?? new SplatMapManager(512);

// 使用空值条件运算符
splatMapManager?.Apply();

// 参数验证
public void SetWeight(Texture2D texture)
{
    if (texture == null)
        throw new ArgumentNullException(nameof(texture));

    // ...
}
```

### LINQ 使用
```csharp
// 简单查询使用LINQ
var activeUnits = units.Where(u => u.IsActive).ToList();

// 复杂逻辑避免过度使用LINQ（性能考虑）
foreach (var unit in units)
{
    if (unit.IsActive && unit.Health > 0)
    {
        ProcessUnit(unit);
    }
}
```

---

## 高性能编程

### Struct vs Class 选择原则

**使用 struct 的场景**：
- 数据量小（<16字节推荐，<64字节可接受）
- 值语义（复制时希望独立副本）
- 生命周期短暂
- 频繁创建和销毁
- 作为数组元素大量使用

```csharp
// ✅ 适合使用struct
public struct Vector3f
{
    public float x, y, z;
}

public struct TerrainVertex
{
    public Vector3f position;
    public Vector3f normal;
    public Vector2f uv;
}

public struct SplatWeight
{
    public float layer0, layer1, layer2, layer3;
}
```

**使用 class 的场景**：
- 数据量大（>64字节）
- 引用语义（需要共享状态）
- 需要继承
- 生命周期长

```csharp
// ✅ 适合使用class
public class TerrainChunk
{
    private Mesh mesh;
    private Material material;
    private TerrainVertex[] vertices;  // 大量数据
}
```

### Struct 最佳实践

#### 1. 设计为不可变（Immutable）
```csharp
// ✅ 推荐：只读struct
public readonly struct Vector3f
{
    public readonly float x;
    public readonly float y;
    public readonly float z;

    public Vector3f(float x, float y, float z)
    {
        this.x = x;
        this.y = y;
        this.z = z;
    }
}

// ❌ 避免：可变struct（容易产生意外的复制）
public struct Vector3f
{
    public float x, y, z;
}
```

#### 2. 实现 IEquatable<T>
```csharp
public readonly struct Vector3f : IEquatable<Vector3f>
{
    public readonly float x, y, z;

    public bool Equals(Vector3f other)
    {
        return x == other.x && y == other.y && z == other.z;
    }

    public override bool Equals(object obj)
    {
        return obj is Vector3f other && Equals(other);
    }

    public override int GetHashCode()
    {
        return HashCode.Combine(x, y, z);
    }
}
```

#### 3. 避免装箱（Boxing）
```csharp
// ❌ 装箱：struct转为object
Vector3f v = new Vector3f(1, 2, 3);
object obj = v;  // 装箱，分配堆内存

// ✅ 避免装箱：使用泛型
public void Process<T>(T value) where T : struct
{
    // 无装箱
}
```

### 指针和Unsafe代码

#### 启用Unsafe代码
在Assembly Definition或csproj中启用：
```json
{
  "allowUnsafeCode": true
}
```

#### 使用场景

**1. 高性能数组操作**
```csharp
public unsafe void ProcessHeightMap(float[] heights, int width, int height)
{
    fixed (float* ptr = heights)
    {
        for (int y = 0; y < height; y++)
        {
            for (int x = 0; x < width; x++)
            {
                int index = y * width + x;
                *(ptr + index) *= 1.1f;  // 直接内存访问
            }
        }
    }
}
```

**2. 纹理数据操作**
```csharp
public unsafe void FillSplatMap(Texture2D texture, byte value)
{
    var pixels = texture.GetRawTextureData<Color32>();
    fixed (Color32* ptr = &pixels[0])
    {
        Color32* current = ptr;
        int count = pixels.Length;

        for (int i = 0; i < count; i++)
        {
            *current = new Color32(value, value, value, value);
            current++;
        }
    }

    texture.Apply();
}
```

**3. 结构体批量处理**
```csharp
public unsafe void TransformVertices(TerrainVertex[] vertices, Matrix4x4f transform)
{
    fixed (TerrainVertex* ptr = vertices)
    {
        TerrainVertex* current = ptr;
        int count = vertices.Length;

        for (int i = 0; i < count; i++)
        {
            current->position = transform.Transform(current->position);
            current++;
        }
    }
}
```

### Unity.Collections 高性能集合

#### NativeArray 使用
```csharp
using Unity.Collections;

public class TerrainMeshGenerator
{
    // ✅ 使用NativeArray避免GC
    public void GenerateMesh(int resolution)
    {
        int vertexCount = resolution * resolution;

        // 分配Native内存
        var vertices = new NativeArray<Vector3>(vertexCount, Allocator.TempJob);
        var normals = new NativeArray<Vector3>(vertexCount, Allocator.TempJob);

        try
        {
            // 处理数据
            for (int i = 0; i < vertexCount; i++)
            {
                vertices[i] = CalculatePosition(i);
                normals[i] = CalculateNormal(i);
            }

            // 应用到Mesh
            mesh.SetVertices(vertices);
            mesh.SetNormals(normals);
        }
        finally
        {
            // 必须手动释放
            vertices.Dispose();
            normals.Dispose();
        }
    }
}
```

#### 使用 using 自动释放
```csharp
public void GenerateMesh(int resolution)
{
    using var vertices = new NativeArray<Vector3>(count, Allocator.TempJob);
    using var normals = new NativeArray<Vector3>(count, Allocator.TempJob);

    // 自动释放，无需手动Dispose
}
```

### Span<T> 和 Memory<T>

#### Span<T> 用于栈分配
```csharp
public void ProcessSmallArray()
{
    // 栈分配，零GC
    Span<float> tempBuffer = stackalloc float[256];

    for (int i = 0; i < tempBuffer.Length; i++)
    {
        tempBuffer[i] = CalculateValue(i);
    }

    ApplyValues(tempBuffer);
}
```

#### 切片操作避免复制
```csharp
public void ProcessSubArray(float[] data, int start, int length)
{
    // ❌ 创建新数组，分配内存
    float[] subArray = new float[length];
    Array.Copy(data, start, subArray, 0, length);

    // ✅ 使用Span切片，零分配
    Span<float> span = data.AsSpan(start, length);
    ProcessSpan(span);
}

private void ProcessSpan(Span<float> values)
{
    for (int i = 0; i < values.Length; i++)
    {
        values[i] *= 2.0f;
    }
}
```

### 对象池模式

```csharp
public class ObjectPool<T> where T : class, new()
{
    private readonly Stack<T> pool = new Stack<T>();
    private readonly int maxSize;

    public ObjectPool(int maxSize = 100)
    {
        this.maxSize = maxSize;
    }

    public T Get()
    {
        return pool.Count > 0 ? pool.Pop() : new T();
    }

    public void Return(T item)
    {
        if (pool.Count < maxSize)
        {
            pool.Push(item);
        }
    }
}

// 使用示例
public class TerrainEditor
{
    private static readonly ObjectPool<List<int>> listPool = new ObjectPool<List<int>>();

    public void ProcessIndices()
    {
        var indices = listPool.Get();
        try
        {
            // 使用列表
            indices.Add(1);
            indices.Add(2);
        }
        finally
        {
            indices.Clear();
            listPool.Return(indices);
        }
    }
}
```

### 内存对齐

```csharp
using System.Runtime.InteropServices;

// 指定内存布局，优化缓存命中
[StructLayout(LayoutKind.Sequential, Pack = 16)]
public struct AlignedVertex
{
    public Vector3f position;     // 12字节
    public float padding1;        // 4字节对齐到16
    public Vector3f normal;       // 12字节
    public float padding2;        // 4字节对齐到16
    public Vector2f uv;           // 8字节
    public Vector2f padding3;     // 8字节对齐到16
}
```

### 性能优化检查清单

数据密集型代码应考虑：
- [ ] 小型数据使用struct而非class
- [ ] Struct设计为readonly
- [ ] 大批量数据处理使用NativeArray
- [ ] 临时缓冲区使用Span<T>/stackalloc
- [ ] 频繁分配对象使用对象池
- [ ] 避免struct装箱
- [ ] 关键路径考虑使用unsafe指针
- [ ] 合理使用ref/in/out参数避免复制

---

## Unity 特定规范

### ScriptableObject
```csharp
[CreateAssetMenu(
    fileName = "NewUnitDefinition",
    menuName = "AceMap/Unit Definition",
    order = 1
)]
public class UnitDefinition : ScriptableObject
{
    [Header("基础属性")]
    [Tooltip("单位显示名称")]
    public string displayName;

    [Range(0, 1000)]
    public float maxHealth = 100f;
}
```

### 序列化字段
```csharp
public class UnitData
{
    [SerializeField]
    private string unitId;

    [SerializeField]
    private float health;

    // 公共访问器
    public string UnitId => unitId;
    public float Health => health;
}
```

### Editor 代码
```csharp
#if UNITY_EDITOR
using UnityEditor;

[CustomEditor(typeof(UnitDefinition))]
public class UnitDefinitionEditor : Editor
{
    public override void OnInspectorGUI()
    {
        DrawDefaultInspector();

        if (GUILayout.Button("验证数据"))
        {
            ValidateData();
        }
    }
}
#endif
```

---

## 性能考虑（补充）

### ref / in / out 参数避免复制

```csharp
// ❌ 大型struct按值传递（复制整个struct）
public void Transform(Matrix4x4f matrix, Vector3f position)
{
    // matrix和position都会被复制
}

// ✅ 使用in参数（只读引用，零复制）
public void Transform(in Matrix4x4f matrix, in Vector3f position)
{
    // 传递引用，不复制
}

// ✅ 使用ref参数（可修改引用）
public void ModifyVertex(ref TerrainVertex vertex)
{
    vertex.position.y += 1.0f;
}

// ✅ 使用out参数（输出）
public bool TryGetVertex(int index, out TerrainVertex vertex)
{
    if (index >= 0 && index < vertices.Length)
    {
        vertex = vertices[index];
        return true;
    }
    vertex = default;
    return false;
}
```

### 避免频繁分配
```csharp
// ❌ 每帧分配新数组
void Update()
{
    var heights = new float[1024];  // ❌
}

// ✅ 重用数组
private float[] heightsCache;

void Initialize()
{
    heightsCache = new float[1024];
}

void Update()
{
    Array.Clear(heightsCache, 0, heightsCache.Length);
}

// ✅ 更好：使用NativeArray（零GC）
private NativeArray<float> heightsCache;

void Initialize()
{
    heightsCache = new NativeArray<float>(1024, Allocator.Persistent);
}

void OnDestroy()
{
    if (heightsCache.IsCreated)
        heightsCache.Dispose();
}
```

### foreach vs for 循环

```csharp
// ❌ foreach可能产生GC（集合类型依赖）
foreach (var item in list)
{
    Process(item);
}

// ✅ for循环无GC
for (int i = 0; i < list.Count; i++)
{
    Process(list[i]);
}

// ✅ Span<T>的foreach不产生GC
Span<int> span = stackalloc int[100];
foreach (var item in span)  // ✅ 无GC
{
    Process(item);
}
```

### 使用StringBuilder
```csharp
// ❌ 字符串拼接
string result = "";
for (int i = 0; i < 100; i++)
{
    result += i.ToString();
}

// ✅ 使用StringBuilder
var sb = new StringBuilder();
for (int i = 0; i < 100; i++)
{
    sb.Append(i);
}
string result = sb.ToString();
```

### 缓存组件引用
```csharp
// ❌ 每次查找
void Update()
{
    GetComponent<Renderer>().enabled = true;
}

// ✅ 缓存引用
private Renderer cachedRenderer;

void Start()
{
    cachedRenderer = GetComponent<Renderer>();
}

void Update()
{
    cachedRenderer.enabled = true;
}
```

### 避免装箱的常见陷阱

```csharp
// ❌ string.Format导致装箱
int value = 42;
string text = string.Format("Value: {0}", value);  // ❌ 装箱

// ✅ 使用插值字符串或直接拼接
string text = $"Value: {value}";  // ✅ 无装箱（C# 10+）

// ❌ 将struct添加到非泛型集合
ArrayList list = new ArrayList();
list.Add(new Vector3f(1, 2, 3));  // ❌ 装箱

// ✅ 使用泛型集合
List<Vector3f> list = new List<Vector3f>();
list.Add(new Vector3f(1, 2, 3));  // ✅ 无装箱
```

---

## 错误处理

### 异常使用
```csharp
// 输入验证
public void SetLayerWeight(int layerId, float weight)
{
    if (layerId < 0)
        throw new ArgumentOutOfRangeException(nameof(layerId), "Layer ID不能为负数");

    if (weight < 0 || weight > 1)
        throw new ArgumentOutOfRangeException(nameof(weight), "权重必须在0-1之间");

    // 正常逻辑
}

// 使用try-catch
public bool LoadMap(string filePath)
{
    try
    {
        var json = File.ReadAllText(filePath);
        var mapData = JsonUtility.FromJson<MapData>(json);
        return true;
    }
    catch (FileNotFoundException)
    {
        Debug.LogError($"地图文件不存在: {filePath}");
        return false;
    }
    catch (Exception ex)
    {
        Debug.LogException(ex);
        return false;
    }
}
```

---

## Git 提交规范

### 提交消息格式
```
<type>(<scope>): <subject>

<body>

<footer>
```

### Type 类型
- `feat`: 新功能
- `fix`: Bug修复
- `docs`: 文档更新
- `style`: 代码格式调整
- `refactor`: 重构
- `perf`: 性能优化
- `test`: 测试相关
- `chore`: 构建/工具相关

### 示例
```
feat(terrain): 实现地形高度编辑功能

- 添加RaiseTerrain和LowerTerrain方法
- 实现笔刷衰减算法
- 添加高度编辑工具UI

Closes #123
```

---

## 代码审查清单

提交代码前检查：
- [ ] 遵循命名约定
- [ ] 添加XML文档注释
- [ ] Core层代码不引用UnityEngine
- [ ] 没有硬编码的magic number
- [ ] 适当的错误处理
- [ ] 移除调试代码和console.log
- [ ] 代码格式化（4空格缩进）
- [ ] 没有警告信息
- [ ] 通过单元测试（如有）
